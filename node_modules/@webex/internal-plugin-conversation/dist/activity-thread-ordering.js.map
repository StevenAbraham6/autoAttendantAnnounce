{"version":3,"sources":["activity-thread-ordering.js"],"names":["setValue","destination","key","value","set","getValue","source","get","defaultMinDisplayableActivities","minBatchSize","fetchLoopCountMax","batchSizeIncrementCount","OLDER","NEWER","MID","INITIAL","ACTIVITY_TYPES","REPLY","EDIT","REACTION","REACTION_SELF","ROOT","CREATE","TOMBSTONE","DELETE","REACTION_SUMMARY","REACTION_SELF_SUMMARY","ADD","getActivityType","activity","activityType","parent","type","verb","getPublishedDate","Date","published","getTime","isNewer","activity1","activity2","getActivityObjectsFromMap","hashMap","map","sortActivitiesByPublishedDate","activities","getParentId","id","isRootActivity","act","isReplyActivity","isEditActivity","isCreateActivity","isDeleteActivity","sanitizeActivity","final","reaction","reactionSelf","replies","activityManager","replyActivityHash","editActivityHash","reactionActivityHash","reactionSelfActivityHash","handleNewReply","replyAct","replyParentId","existingReplyHash","replyHash","handleNewEdit","editAct","isTombstone","editParentId","existingEdit","reactionHelper","reactionAct","hash","reactionParentId","existingReaction","handleNewReaction","handleNewReactionSelf","reactionSelfAct","getActivityHandlerByKey","getActivityByTypeAndParentId","bookendManager","oldestAct","newestAct","getOldestAct","getNewestAct","setOldestAct","setNewestAct","setBookends","oldestActsFirst","newestInBatch","oldestInBatch","noMoreActivitiesManager","noMoreActs","noOlderActs","noNewerActs","getNoMoreActs","checkAndSetNoOlderActs","checkAndSetNoNewerActs","length","checkAndSetNoMoreActs","queryType","rootActivityManager","rootActivityHash","addNewRoot","rootAct","getRootActivityHash","getLoopCounterFailsafe","fetchLoopCount","Error","getQuery","queryOptions","newestPublishedDate","oldestPublishedDate","batchSize","activityToSearch","sinceDate","lastActivityFirst","searchType","midDate","limit","maxDate"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;;;;;;AAMO,IAAMA,8BAAW,SAAXA,QAAW,CAACC,WAAD,EAAcC,GAAd,EAAmBC,KAAnB;AAAA,SAA6BF,YAAYG,GAAZ,CAAgBF,GAAhB,EAAqBC,KAArB,CAA7B;AAAA,CAAjB;AACP;;;;;AAKO,IAAME,8BAAW,SAAXA,QAAW,CAACC,MAAD,EAASJ,GAAT;AAAA,SAAiBI,OAAOC,GAAP,CAAWL,GAAX,CAAjB;AAAA,CAAjB;;AAEA,IAAMM,4EAAkC,EAAxC;AACA,IAAMC,sCAAe,EAArB;AACA,IAAMC,gDAAoB,GAA1B;AACA,IAAMC,4DAA0B,EAAhC;;AAEA,IAAMC,wBAAQ,OAAd;AACA,IAAMC,wBAAQ,OAAd;AACA,IAAMC,oBAAM,KAAZ;AACA,IAAMC,4BAAU,SAAhB;;AAEA,IAAMC,0CAAiB;AAC5BC,SAAO,OADqB;AAE5BC,QAAM,MAFsB;AAG5BC,YAAU,UAHkB;AAI5BC,iBAAe,eAJa;AAK5BC,QAAM,MALsB;AAM5BC,UAAQ,QANoB;AAO5BC,aAAW,WAPiB;AAQ5BC,UAAQ;AARoB,CAAvB;;AAWP,IAAMP,QAAQ,OAAd;AACA,IAAMC,OAAO,MAAb;AACA,IAAMO,mBAAmB,iBAAzB;AACA,IAAMC,wBAAwB,qBAA9B;AACA,IAAMJ,SAAS,QAAf;AACA,IAAMC,YAAY,WAAlB;AACA,IAAMC,SAAS,QAAf;AACA,IAAMG,MAAM,KAAZ;;AAEO,IAAMC,4CAAkB,SAAlBA,eAAkB,CAACC,QAAD,EAAc;AAC3C,MAAIA,SAASC,YAAT,KAA0Bb,KAA9B,EAAqC;AACnC,WAAOD,eAAeC,KAAtB;AACD;AACD,MAAIY,SAASE,MAAT,IAAmBF,SAASE,MAAT,CAAgBC,IAAhB,KAAyBd,IAAhD,EAAsD;AACpD,WAAOF,eAAeE,IAAtB;AACD;AACD,MAAIW,SAASI,IAAT,KAAkBN,GAAlB,IAAyBE,SAASG,IAAT,KAAkBP,gBAA/C,EAAiE;AAC/D,WAAOT,eAAeG,QAAtB;AACD;AACD,MAAIU,SAASG,IAAT,KAAkBN,qBAAtB,EAA6C;AAC3C,WAAOV,eAAeI,aAAtB;AACD;AACD,MAAIS,SAASI,IAAT,KAAkBX,MAAtB,EAA8B;AAC5B,WAAON,eAAeM,MAAtB;AACD;AACD,MAAIO,SAASI,IAAT,KAAkBV,SAAtB,EAAiC;AAC/B,WAAOP,eAAeO,SAAtB;AACD;AACD,MAAIM,SAASI,IAAT,KAAkBT,MAAtB,EAA8B;AAC5B,WAAOR,eAAeQ,MAAtB;AACD;;AAED,SAAOR,eAAeK,IAAtB;AACD,CAxBM;;AA0BA,IAAMa,8CAAmB,SAAnBA,gBAAmB;AAAA,MAACL,QAAD,uEAAY,EAAZ;AAAA,SAAmB,IAAIM,IAAJ,CAASN,SAASO,SAAlB,EAA6BC,OAA7B,EAAnB;AAAA,CAAzB;;AAEP;;;;;AAKO,IAAMC,4BAAU,SAAVA,OAAU,CAACC,SAAD,EAAYC,SAAZ;AAAA,SAA0BN,iBAAiBK,SAAjB,IAA8BL,iBAAiBM,SAAjB,CAAxD;AAAA,CAAhB;;AAEA,IAAMC,gEAA4B,SAA5BA,yBAA4B,CAACC,OAAD;AAAA,SAAa,oBAAWA,OAAX,EAAoBC,GAApB,CAAwB;AAAA;AAAA,QAAId,QAAJ;;AAAA,WAAkBA,QAAlB;AAAA,GAAxB,CAAb;AAAA,CAAlC;;AAEA,IAAMe,wEAAgC,SAAhCA,6BAAgC,CAACC,UAAD;AAAA,SAAgB,sBAAOA,UAAP,EAAmB,UAAChB,QAAD;AAAA,WAAcK,iBAAiBL,QAAjB,CAAd;AAAA,GAAnB,CAAhB;AAAA,CAAtC;;AAEA,IAAMiB,oCAAc,SAAdA,WAAc,CAACjB,QAAD;AAAA,SAAcA,YAAYA,SAASE,MAArB,IAA+BF,SAASE,MAAT,CAAgBgB,EAA7D;AAAA,CAApB;;AAEA,IAAMC,0CAAiB,SAAjBA,cAAiB,CAACC,GAAD;AAAA,SAASrB,gBAAgBqB,GAAhB,MAAyBjC,eAAeK,IAAjD;AAAA,CAAvB;AACA,IAAM6B,4CAAkB,SAAlBA,eAAkB,CAACD,GAAD;AAAA,SAASrB,gBAAgBqB,GAAhB,MAAyBjC,eAAeC,KAAjD;AAAA,CAAxB;AACA,IAAMkC,0CAAiB,SAAjBA,cAAiB,CAACF,GAAD;AAAA,SAASrB,gBAAgBqB,GAAhB,MAAyBjC,eAAeE,IAAjD;AAAA,CAAvB;AACA,IAAMkC,8CAAmB,SAAnBA,gBAAmB,CAACH,GAAD;AAAA,SAASrB,gBAAgBqB,GAAhB,MAAyBjC,eAAeM,MAAjD;AAAA,CAAzB;AACA,IAAM+B,8CAAmB,SAAnBA,gBAAmB,CAACJ,GAAD;AAAA,SAASrB,gBAAgBqB,GAAhB,MAAyBjC,eAAeQ,MAAjD;AAAA,CAAzB;;AAEA,IAAM8B,8CAAmB,SAAnBA,gBAAmB,CAACzB,QAAD,EAAc;AAC5C,MAAM0B,mCAAY1B,QAAZ,CAAN;;AAEA0B,QAAMC,QAAN,GAAiB3B,SAAS2B,QAAT,IAAqB,EAAtC;AACAD,QAAME,YAAN,GAAqB5B,SAAS4B,YAAT,IAAyB,EAA9C;;AAEA;AACA,SAAOF,MAAMG,OAAb;;AAEA,SAAOH,KAAP;AACD,CAVM;;AAYP;;;;;;;;AAQO,IAAMI,4CAAkB,SAAlBA,eAAkB,GAAM;AACnC,MAAMC,oBAAoB,mBAA1B;AACA,MAAMC,mBAAmB,mBAAzB;AACA,MAAMC,uBAAuB,mBAA7B;AACA,MAAMC,2BAA2B,mBAAjC;;AAEA,MAAMC,iBAAiB,SAAjBA,cAAiB,CAACC,QAAD,EAAc;AACnC,QAAMC,gBAAgBpB,YAAYmB,QAAZ,CAAtB;AACA,QAAME,oBAAoB9D,SAASuD,iBAAT,EAA4BM,aAA5B,CAA1B;;AAEA,QAAIC,iBAAJ,EAAuB;AACrBnE,eAASmE,iBAAT,EAA4BF,SAASlB,EAArC,EAAyCkB,QAAzC;AACD,KAFD,MAGK;AACH,UAAMG,YAAY,mBAAlB;;AAEApE,eAASoE,SAAT,EAAoBH,SAASlB,EAA7B,EAAiCkB,QAAjC;AACAjE,eAAS4D,iBAAT,EAA4BM,aAA5B,EAA2CE,SAA3C;AACD;AACF,GAbD;;AAeA,MAAMC,gBAAgB,SAAhBA,aAAgB,CAACC,OAAD,EAAa;AACjC,QAAMC,cAAcD,QAAQrC,IAAR,KAAiBjB,eAAeO,SAApD;;AAEA;AACA,QAAIgD,WAAJ,EAAiB;AACf;AACD;;AAED,QAAMC,eAAe1B,YAAYwB,OAAZ,CAArB;AACA,QAAMG,eAAepE,SAASwD,gBAAT,EAA2BW,YAA3B,CAArB;;AAEA;AACA,QAAI,CAACC,YAAD,IAAiBnC,QAAQgC,OAAR,EAAiBG,YAAjB,CAArB,EAAqD;AACnDzE,eAAS6D,gBAAT,EAA2BW,YAA3B,EAAyCF,OAAzC;AACD;AACF,GAfD;;AAiBA;AACA,MAAMI,iBAAiB,SAAjBA,cAAiB,CAACC,WAAD,EAAcC,IAAd,EAAuB;AAC5C,QAAMC,mBAAmB/B,YAAY6B,WAAZ,CAAzB;AACA,QAAMG,mBAAmBzE,SAASuE,IAAT,EAAeC,gBAAf,CAAzB;;AAEA;AACA,QAAI,CAACC,gBAAD,IAAqBxC,QAAQqC,WAAR,EAAqBG,gBAArB,CAAzB,EAAiE;AAC/D9E,eAAS4E,IAAT,EAAeC,gBAAf,EAAiCF,WAAjC;AACD;AACF,GARD;;AAUA,MAAMI,oBAAoB,SAApBA,iBAAoB,CAACJ,WAAD,EAAiB;AACzCD,mBAAeC,WAAf,EAA4Bb,oBAA5B;AACD,GAFD;;AAIA,MAAMkB,wBAAwB,SAAxBA,qBAAwB,CAACC,eAAD,EAAqB;AACjDP,mBAAeO,eAAf,EAAgClB,wBAAhC;AACD,GAFD;;AAIA,MAAMmB,0BAA0B,SAA1BA,uBAA0B,CAAChF,GAAD;AAAA;;AAAA,WAAU,kFACvCc,eAAeG,QADwB,EACb4D,iBADa,wDAEvC/D,eAAeI,aAFwB,EAER4D,qBAFQ,wDAGvChE,eAAeE,IAHwB,EAGjBmD,aAHiB,wDAIvCrD,eAAeC,KAJwB,EAIhB+C,cAJgB,0BAKxC9D,GALwC,CAAV;AAAA,GAAhC;;AAOA,MAAMiF,+BAA+B,SAA/BA,4BAA+B,CAACnD,IAAD,EAAOe,EAAP;AAAA;;AAAA,WAAe,kFACjD/B,eAAeE,IADkC,EAC3Bb,SAASwD,gBAAT,EAA2Bd,EAA3B,CAD2B,wDAEjD/B,eAAeC,KAFkC,EAE1BZ,SAASuD,iBAAT,EAA4Bb,EAA5B,CAF0B,wDAGjD/B,eAAeG,QAHkC,EAGvBd,SAASyD,oBAAT,EAA+Bf,EAA/B,CAHuB,wDAIjD/B,eAAeI,aAJkC,EAIlBf,SAAS0D,wBAAT,EAAmChB,EAAnC,CAJkB,0BAKlDf,IALkD,CAAf;AAAA,GAArC;;AAOA,SAAO;AACLkD,oDADK;AAELC;AAFK,GAAP;AAID,CA3EM;;AA6EP;;;;AAIO,IAAMC,0CAAiB,SAAjBA,cAAiB,GAAM;AAClC;AACA,MAAIC,kBAAJ;AACA,MAAIC,kBAAJ;;AAEA,MAAMC,eAAe,SAAfA,YAAe;AAAA,WAAMF,SAAN;AAAA,GAArB;AACA,MAAMG,eAAe,SAAfA,YAAe;AAAA,WAAMF,SAAN;AAAA,GAArB;;AAEA,MAAMG,eAAe,SAAfA,YAAe,CAACxC,GAAD,EAAS;AAC5B,QAAI,CAACoC,SAAL,EAAgB;AACdA,kBAAYpC,GAAZ;AACD,KAFD,MAGK,IAAIX,QAAQ+C,SAAR,EAAmBpC,GAAnB,CAAJ,EAA6B;AAChCoC,kBAAYpC,GAAZ;AACD;AACF,GAPD;;AASA,MAAMyC,eAAe,SAAfA,YAAe,CAACzC,GAAD,EAAS;AAC5B,QAAI,CAACqC,SAAL,EAAgB;AACdA,kBAAYrC,GAAZ;AACD,KAFD,MAGK,IAAIX,QAAQW,GAAR,EAAaqC,SAAb,CAAJ,EAA6B;AAChCA,kBAAYrC,GAAZ;AACD;AACF,GAPD;;AASA,MAAM0C,cAAc,SAAdA,WAAc,CAAC9C,UAAD,EAAgB;AAClC,QAAM+C,kBAAkBhD,8BAA8BC,UAA9B,CAAxB;;AAEA,QAAMgD,gBAAgB,oBAAKD,eAAL,CAAtB;AACA,QAAME,gBAAgBF,gBAAgB,CAAhB,CAAtB;;AAEAH,iBAAaK,aAAb;AACAJ,iBAAaG,aAAb;AACD,GARD;;AAUA,SAAO;AACLF,4BADK;AAELH,8BAFK;AAGLD;AAHK,GAAP;AAKD,CAzCM;;AA2CP;;;;AAIO,IAAMQ,4DAA0B,SAA1BA,uBAA0B,GAAM;AAC3C;AACA;AACA,MAAIC,aAAa,KAAjB;AACA,MAAIC,cAAc,KAAlB;AACA,MAAIC,cAAc,KAAlB;;AAEA,MAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,WAAMH,UAAN;AAAA,GAAtB;;AAEA,MAAMI,yBAAyB,SAAzBA,sBAAyB,CAACnD,GAAD,EAAS;AACtC,QAAI,CAACgD,WAAD,IAAgBrE,gBAAgBqB,GAAhB,MAAyBjC,eAAeM,MAA5D,EAAoE;AAClE2E,oBAAc,IAAd;AACD;AACF,GAJD;;AAMA,MAAMI,yBAAyB,SAAzBA,sBAAyB,CAACxD,UAAD,EAAgB;AAC7C,QAAI,CAACA,UAAD,IAAe,CAACA,WAAWyD,MAA/B,EAAuC;AACrCJ,oBAAc,IAAd;AACD;AACF,GAJD;;AAMA,MAAMK,wBAAwB,SAAxBA,qBAAwB,CAACC,SAAD,EAAe;AAC3C,QACGA,cAAc3F,KAAd,IAAuBqF,WAAxB,IACC,CAACM,cAAc5F,KAAd,IAAuB4F,cAAczF,OAAtC,KAAkDkF,WAFrD,EAGE;AACAD,mBAAa,IAAb;AACD;AACF,GAPD;;AASA,SAAO;AACLG,gCADK;AAELI,gDAFK;AAGLF,kDAHK;AAILD;AAJK,GAAP;AAMD,CApCM;;AAsCP;;;;AAIO,IAAMK,oDAAsB,SAAtBA,mBAAsB,GAAM;AACvC,MAAMC,mBAAmB,mBAAzB;;AAEA,MAAMC,aAAa,SAAbA,UAAa,CAACC,OAAD,EAAa;AAC9B5G,aAAS0G,gBAAT,EAA2BE,QAAQ7D,EAAnC,EAAuC6D,OAAvC;AACD,GAFD;;AAIA,MAAMC,sBAAsB,SAAtBA,mBAAsB;AAAA,WAAMH,gBAAN;AAAA,GAA5B;;AAEA,SAAO;AACLC,0BADK;AAELE;AAFK,GAAP;AAID,CAbM;;AAeA,IAAMC,0DAAyB,SAAzBA,sBAAyB,GAAM;AAC1C,MAAIC,iBAAiB,CAArB;;AAEA,SAAO,YAAM;AACXA,sBAAkB,CAAlB;AACA,QAAIA,iBAAiBrG,iBAArB,EAAwC;AACtC,YAAM,IAAIsG,KAAJ,CAAU,qBAAV,CAAN;AACD;AACF,GALD;AAMD,CATM;;AAWP;;;;;;;;;;AAUO,IAAMC,8BAAW,SAAXA,QAAW,CAACjF,IAAD,EAAOkF,YAAP,EAAwB;AAAA,MAE5CC,mBAF4C,GAG1CD,YAH0C,CAE5CC,mBAF4C;AAAA,MAEvBC,mBAFuB,GAG1CF,YAH0C,CAEvBE,mBAFuB;AAAA,MAEFC,SAFE,GAG1CH,YAH0C,CAEFG,SAFE;AAAA,8BAG1CH,YAH0C,CAESI,gBAFT;AAAA,MAESA,gBAFT,yCAE4B,EAF5B;;;AAK9C,UAAQtF,IAAR;AACE,SAAKnB,KAAL;AAAY;AACV,YAAM0G,YAAYJ,sBAAsB,CAAxC;AACA,YAAMK,oBAAoB,KAA1B;;AAEA,eAAO,EAACD,oBAAD,EAAYC,oCAAZ,EAAP;AACD;AACD,SAAK1G,GAAL;AAAU;AACR,YAAM2G,aAAa7F,gBAAgB0F,gBAAhB,CAAnB;AACA,YAAII,gBAAJ;;AAEA,YAAID,eAAezG,eAAeC,KAA9B,IAAuCwG,eAAezG,eAAeE,IAAzE,EAA+E;AAC7EwG,oBAAUJ,iBAAiBvF,MAAjB,CAAwBK,SAAlC;AACD,SAFD,MAGK;AACHsF,oBAAUJ,iBAAiBlF,SAA3B;AACD;;AAED,eAAO,EAACsF,gBAAD,EAAUC,OAAON,SAAjB,EAAP;AACD;AACD,SAAKzG,KAAL;AAAY;AACV,YAAMgH,UAAUR,sBAAsB,CAAtC;;AAEA,eAAO,EAACQ,gBAAD,EAAP;AACD;AACD,SAAK7G,OAAL;AACA;AAAS;AACP,eAAO,EAAP;AACD;AA5BH;AA8BD,CAnCM","file":"activity-thread-ordering.js","sourcesContent":["import {sortBy, last} from 'lodash';\n\n// use accessors for ease of refactoring underlying implementation\n/**\n * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.\n * @param {string} key\n * @param {any} value\n * @returns {Map}\n */\nexport const setValue = (destination, key, value) => destination.set(key, value);\n/**\n * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type\n * @param {string} key\n * @returns {Map}\n */\nexport const getValue = (source, key) => source.get(key);\n\nexport const defaultMinDisplayableActivities = 20;\nexport const minBatchSize = 10;\nexport const fetchLoopCountMax = 100;\nexport const batchSizeIncrementCount = 10;\n\nexport const OLDER = 'older';\nexport const NEWER = 'newer';\nexport const MID = 'mid';\nexport const INITIAL = 'initial';\n\nexport const ACTIVITY_TYPES = {\n  REPLY: 'REPLY',\n  EDIT: 'EDIT',\n  REACTION: 'REACTION',\n  REACTION_SELF: 'REACTION_SELF',\n  ROOT: 'ROOT',\n  CREATE: 'CREATE',\n  TOMBSTONE: 'TOMBSTONE',\n  DELETE: 'DELETE'\n};\n\nconst REPLY = 'reply';\nconst EDIT = 'edit';\nconst REACTION_SUMMARY = 'reactionSummary';\nconst REACTION_SELF_SUMMARY = 'reactionSelfSummary';\nconst CREATE = 'create';\nconst TOMBSTONE = 'tombstone';\nconst DELETE = 'delete';\nconst ADD = 'add';\n\nexport const getActivityType = (activity) => {\n  if (activity.activityType === REPLY) {\n    return ACTIVITY_TYPES.REPLY;\n  }\n  if (activity.parent && activity.parent.type === EDIT) {\n    return ACTIVITY_TYPES.EDIT;\n  }\n  if (activity.verb === ADD || activity.type === REACTION_SUMMARY) {\n    return ACTIVITY_TYPES.REACTION;\n  }\n  if (activity.type === REACTION_SELF_SUMMARY) {\n    return ACTIVITY_TYPES.REACTION_SELF;\n  }\n  if (activity.verb === CREATE) {\n    return ACTIVITY_TYPES.CREATE;\n  }\n  if (activity.verb === TOMBSTONE) {\n    return ACTIVITY_TYPES.TOMBSTONE;\n  }\n  if (activity.verb === DELETE) {\n    return ACTIVITY_TYPES.DELETE;\n  }\n\n  return ACTIVITY_TYPES.ROOT;\n};\n\nexport const getPublishedDate = (activity = {}) => new Date(activity.published).getTime();\n\n/**\n * @param {Object} activity1\n * @param {Object} activity2\n * @returns {boolean} true if first activity is newer than second\n */\nexport const isNewer = (activity1, activity2) => getPublishedDate(activity1) > getPublishedDate(activity2);\n\nexport const getActivityObjectsFromMap = (hashMap) => Array.from(hashMap).map(([, activity]) => activity);\n\nexport const sortActivitiesByPublishedDate = (activities) => sortBy(activities, (activity) => getPublishedDate(activity));\n\nexport const getParentId = (activity) => activity && activity.parent && activity.parent.id;\n\nexport const isRootActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.ROOT;\nexport const isReplyActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.REPLY;\nexport const isEditActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.EDIT;\nexport const isCreateActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.CREATE;\nexport const isDeleteActivity = (act) => getActivityType(act) === ACTIVITY_TYPES.DELETE;\n\nexport const sanitizeActivity = (activity) => {\n  const final = {...activity};\n\n  final.reaction = activity.reaction || {};\n  final.reactionSelf = activity.reactionSelf || {};\n\n  // replies will be spread in order beneath parent, no need to include on final objects\n  delete final.replies;\n\n  return final;\n};\n\n/**\n * creates maps for various activity types and defines handlers for working with stored activities\n * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state\n * @function\n * @returns {object}\n * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler\n * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId\n */\nexport const activityManager = () => {\n  const replyActivityHash = new Map();\n  const editActivityHash = new Map();\n  const reactionActivityHash = new Map();\n  const reactionSelfActivityHash = new Map();\n\n  const handleNewReply = (replyAct) => {\n    const replyParentId = getParentId(replyAct);\n    const existingReplyHash = getValue(replyActivityHash, replyParentId);\n\n    if (existingReplyHash) {\n      setValue(existingReplyHash, replyAct.id, replyAct);\n    }\n    else {\n      const replyHash = new Map();\n\n      setValue(replyHash, replyAct.id, replyAct);\n      setValue(replyActivityHash, replyParentId, replyHash);\n    }\n  };\n\n  const handleNewEdit = (editAct) => {\n    const isTombstone = editAct.verb === ACTIVITY_TYPES.TOMBSTONE;\n\n    // we can ignore tombstone edits in favor of the newer one\n    if (isTombstone) {\n      return;\n    }\n\n    const editParentId = getParentId(editAct);\n    const existingEdit = getValue(editActivityHash, editParentId);\n\n    // edited activity must be newer than what we already have\n    if (!existingEdit || isNewer(editAct, existingEdit)) {\n      setValue(editActivityHash, editParentId, editAct);\n    }\n  };\n\n  // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash\n  const reactionHelper = (reactionAct, hash) => {\n    const reactionParentId = getParentId(reactionAct);\n    const existingReaction = getValue(hash, reactionParentId);\n\n    // reaction activity must be newer than what we already have\n    if (!existingReaction || isNewer(reactionAct, existingReaction)) {\n      setValue(hash, reactionParentId, reactionAct);\n    }\n  };\n\n  const handleNewReaction = (reactionAct) => {\n    reactionHelper(reactionAct, reactionActivityHash);\n  };\n\n  const handleNewReactionSelf = (reactionSelfAct) => {\n    reactionHelper(reactionSelfAct, reactionSelfActivityHash);\n  };\n\n  const getActivityHandlerByKey = (key) => ({\n    [ACTIVITY_TYPES.REACTION]: handleNewReaction,\n    [ACTIVITY_TYPES.REACTION_SELF]: handleNewReactionSelf,\n    [ACTIVITY_TYPES.EDIT]: handleNewEdit,\n    [ACTIVITY_TYPES.REPLY]: handleNewReply\n  }[key]);\n\n  const getActivityByTypeAndParentId = (type, id) => ({\n    [ACTIVITY_TYPES.EDIT]: getValue(editActivityHash, id),\n    [ACTIVITY_TYPES.REPLY]: getValue(replyActivityHash, id),\n    [ACTIVITY_TYPES.REACTION]: getValue(reactionActivityHash, id),\n    [ACTIVITY_TYPES.REACTION_SELF]: getValue(reactionSelfActivityHash, id)\n  }[type]);\n\n  return {\n    getActivityHandlerByKey,\n    getActivityByTypeAndParentId\n  };\n};\n\n/**\n * encapsulates state and logic for managing oldest and newest activities\n * @returns {object} setters and getters for activity state management\n */\nexport const bookendManager = () => {\n  // keep track of generator state, like what our current oldest & newest activities are\n  let oldestAct;\n  let newestAct;\n\n  const getOldestAct = () => oldestAct;\n  const getNewestAct = () => newestAct;\n\n  const setOldestAct = (act) => {\n    if (!oldestAct) {\n      oldestAct = act;\n    }\n    else if (isNewer(oldestAct, act)) {\n      oldestAct = act;\n    }\n  };\n\n  const setNewestAct = (act) => {\n    if (!newestAct) {\n      newestAct = act;\n    }\n    else if (isNewer(act, newestAct)) {\n      newestAct = act;\n    }\n  };\n\n  const setBookends = (activities) => {\n    const oldestActsFirst = sortActivitiesByPublishedDate(activities);\n\n    const newestInBatch = last(oldestActsFirst);\n    const oldestInBatch = oldestActsFirst[0];\n\n    setOldestAct(oldestInBatch);\n    setNewestAct(newestInBatch);\n  };\n\n  return {\n    setBookends,\n    getNewestAct,\n    getOldestAct\n  };\n};\n\n/**\n * encapsulates state and logic for when there are no more fetchable activities from convo\n * @returns {object} setters and getters for no more activities logic\n */\nexport const noMoreActivitiesManager = () => {\n  // used to determine if we should continue to fetch older activities\n  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached\n  let noMoreActs = false;\n  let noOlderActs = false;\n  let noNewerActs = false;\n\n  const getNoMoreActs = () => noMoreActs;\n\n  const checkAndSetNoOlderActs = (act) => {\n    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {\n      noOlderActs = true;\n    }\n  };\n\n  const checkAndSetNoNewerActs = (activities) => {\n    if (!activities || !activities.length) {\n      noNewerActs = true;\n    }\n  };\n\n  const checkAndSetNoMoreActs = (queryType) => {\n    if (\n      (queryType === NEWER && noNewerActs) ||\n      ((queryType === OLDER || queryType === INITIAL) && noOlderActs)\n    ) {\n      noMoreActs = true;\n    }\n  };\n\n  return {\n    getNoMoreActs,\n    checkAndSetNoMoreActs,\n    checkAndSetNoNewerActs,\n    checkAndSetNoOlderActs\n  };\n};\n\n/**\n * encapsulates state and logic for managing root activities\n * @returns {object} setters and getters for activity state management\n */\nexport const rootActivityManager = () => {\n  const rootActivityHash = new Map();\n\n  const addNewRoot = (rootAct) => {\n    setValue(rootActivityHash, rootAct.id, rootAct);\n  };\n\n  const getRootActivityHash = () => rootActivityHash;\n\n  return {\n    addNewRoot,\n    getRootActivityHash\n  };\n};\n\nexport const getLoopCounterFailsafe = () => {\n  let fetchLoopCount = 0;\n\n  return () => {\n    fetchLoopCount += 1;\n    if (fetchLoopCount > fetchLoopCountMax) {\n      throw new Error('max fetches reached');\n    }\n  };\n};\n\n/**\n * creates activity query object\n * @param {string} type type of query to create\n * @param {object} queryOptions options to define query\n * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity\n * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity\n * @param {number} [queryOptions.batchSize] the number of activities to query\n * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query\n * @returns {object}\n */\nexport const getQuery = (type, queryOptions) => {\n  const {\n    newestPublishedDate, oldestPublishedDate, batchSize, activityToSearch = {}\n  } = queryOptions;\n\n  switch (type) {\n    case NEWER: {\n      const sinceDate = newestPublishedDate + 1;\n      const lastActivityFirst = false;\n\n      return {sinceDate, lastActivityFirst};\n    }\n    case MID: {\n      const searchType = getActivityType(activityToSearch);\n      let midDate;\n\n      if (searchType === ACTIVITY_TYPES.REPLY || searchType === ACTIVITY_TYPES.EDIT) {\n        midDate = activityToSearch.parent.published;\n      }\n      else {\n        midDate = activityToSearch.published;\n      }\n\n      return {midDate, limit: batchSize};\n    }\n    case OLDER: {\n      const maxDate = oldestPublishedDate - 1;\n\n      return {maxDate};\n    }\n    case INITIAL:\n    default: {\n      return {};\n    }\n  }\n};\n"]}