'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQuery = exports.getLoopCounterFailsafe = exports.rootActivityManager = exports.noMoreActivitiesManager = exports.bookendManager = exports.activityManager = exports.sanitizeActivity = exports.isDeleteActivity = exports.isCreateActivity = exports.isEditActivity = exports.isReplyActivity = exports.isRootActivity = exports.getParentId = exports.sortActivitiesByPublishedDate = exports.getActivityObjectsFromMap = exports.isNewer = exports.getPublishedDate = exports.getActivityType = exports.ACTIVITY_TYPES = exports.INITIAL = exports.MID = exports.NEWER = exports.OLDER = exports.batchSizeIncrementCount = exports.fetchLoopCountMax = exports.minBatchSize = exports.defaultMinDisplayableActivities = exports.getValue = exports.setValue = undefined;

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _map = require('babel-runtime/core-js/map');

var _map2 = _interopRequireDefault(_map);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

var _last2 = require('lodash/last');

var _last3 = _interopRequireDefault(_last2);

var _sortBy2 = require('lodash/sortBy');

var _sortBy3 = _interopRequireDefault(_sortBy2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// use accessors for ease of refactoring underlying implementation
/**
 * @param {Map} destination destination map object for data. Currently a Map, but could be refactored to use any type.
 * @param {string} key
 * @param {any} value
 * @returns {Map}
 */
var setValue = exports.setValue = function setValue(destination, key, value) {
  return destination.set(key, value);
};
/**
 * @param {Map} source source map object to access. Currently expects a Map, but could be refactored to use any type
 * @param {string} key
 * @returns {Map}
 */
var getValue = exports.getValue = function getValue(source, key) {
  return source.get(key);
};

var defaultMinDisplayableActivities = exports.defaultMinDisplayableActivities = 20;
var minBatchSize = exports.minBatchSize = 10;
var fetchLoopCountMax = exports.fetchLoopCountMax = 100;
var batchSizeIncrementCount = exports.batchSizeIncrementCount = 10;

var OLDER = exports.OLDER = 'older';
var NEWER = exports.NEWER = 'newer';
var MID = exports.MID = 'mid';
var INITIAL = exports.INITIAL = 'initial';

var ACTIVITY_TYPES = exports.ACTIVITY_TYPES = {
  REPLY: 'REPLY',
  EDIT: 'EDIT',
  REACTION: 'REACTION',
  REACTION_SELF: 'REACTION_SELF',
  ROOT: 'ROOT',
  CREATE: 'CREATE',
  TOMBSTONE: 'TOMBSTONE',
  DELETE: 'DELETE'
};

var REPLY = 'reply';
var EDIT = 'edit';
var REACTION_SUMMARY = 'reactionSummary';
var REACTION_SELF_SUMMARY = 'reactionSelfSummary';
var CREATE = 'create';
var TOMBSTONE = 'tombstone';
var DELETE = 'delete';
var ADD = 'add';

var getActivityType = exports.getActivityType = function getActivityType(activity) {
  if (activity.activityType === REPLY) {
    return ACTIVITY_TYPES.REPLY;
  }
  if (activity.parent && activity.parent.type === EDIT) {
    return ACTIVITY_TYPES.EDIT;
  }
  if (activity.verb === ADD || activity.type === REACTION_SUMMARY) {
    return ACTIVITY_TYPES.REACTION;
  }
  if (activity.type === REACTION_SELF_SUMMARY) {
    return ACTIVITY_TYPES.REACTION_SELF;
  }
  if (activity.verb === CREATE) {
    return ACTIVITY_TYPES.CREATE;
  }
  if (activity.verb === TOMBSTONE) {
    return ACTIVITY_TYPES.TOMBSTONE;
  }
  if (activity.verb === DELETE) {
    return ACTIVITY_TYPES.DELETE;
  }

  return ACTIVITY_TYPES.ROOT;
};

var getPublishedDate = exports.getPublishedDate = function getPublishedDate() {
  var activity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new Date(activity.published).getTime();
};

/**
 * @param {Object} activity1
 * @param {Object} activity2
 * @returns {boolean} true if first activity is newer than second
 */
var isNewer = exports.isNewer = function isNewer(activity1, activity2) {
  return getPublishedDate(activity1) > getPublishedDate(activity2);
};

var getActivityObjectsFromMap = exports.getActivityObjectsFromMap = function getActivityObjectsFromMap(hashMap) {
  return (0, _from2.default)(hashMap).map(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        activity = _ref2[1];

    return activity;
  });
};

var sortActivitiesByPublishedDate = exports.sortActivitiesByPublishedDate = function sortActivitiesByPublishedDate(activities) {
  return (0, _sortBy3.default)(activities, function (activity) {
    return getPublishedDate(activity);
  });
};

var getParentId = exports.getParentId = function getParentId(activity) {
  return activity && activity.parent && activity.parent.id;
};

var isRootActivity = exports.isRootActivity = function isRootActivity(act) {
  return getActivityType(act) === ACTIVITY_TYPES.ROOT;
};
var isReplyActivity = exports.isReplyActivity = function isReplyActivity(act) {
  return getActivityType(act) === ACTIVITY_TYPES.REPLY;
};
var isEditActivity = exports.isEditActivity = function isEditActivity(act) {
  return getActivityType(act) === ACTIVITY_TYPES.EDIT;
};
var isCreateActivity = exports.isCreateActivity = function isCreateActivity(act) {
  return getActivityType(act) === ACTIVITY_TYPES.CREATE;
};
var isDeleteActivity = exports.isDeleteActivity = function isDeleteActivity(act) {
  return getActivityType(act) === ACTIVITY_TYPES.DELETE;
};

var sanitizeActivity = exports.sanitizeActivity = function sanitizeActivity(activity) {
  var final = (0, _extends3.default)({}, activity);

  final.reaction = activity.reaction || {};
  final.reactionSelf = activity.reactionSelf || {};

  // replies will be spread in order beneath parent, no need to include on final objects
  delete final.replies;

  return final;
};

/**
 * creates maps for various activity types and defines handlers for working with stored activities
 * utilizes revealing module pattern to close over state and only expose certain necessary functions for altering state
 * @function
 * @returns {object}
 * getActivityHandlerByKey(activityType) - accepts a key to map to a defined activity handler
 * getActivityByTypeAndParentId(activityType, parentId) accepts a key and a parent ID to return an activity of that type whose parent is the parentId
 */
var activityManager = exports.activityManager = function activityManager() {
  var replyActivityHash = new _map2.default();
  var editActivityHash = new _map2.default();
  var reactionActivityHash = new _map2.default();
  var reactionSelfActivityHash = new _map2.default();

  var handleNewReply = function handleNewReply(replyAct) {
    var replyParentId = getParentId(replyAct);
    var existingReplyHash = getValue(replyActivityHash, replyParentId);

    if (existingReplyHash) {
      setValue(existingReplyHash, replyAct.id, replyAct);
    } else {
      var replyHash = new _map2.default();

      setValue(replyHash, replyAct.id, replyAct);
      setValue(replyActivityHash, replyParentId, replyHash);
    }
  };

  var handleNewEdit = function handleNewEdit(editAct) {
    var isTombstone = editAct.verb === ACTIVITY_TYPES.TOMBSTONE;

    // we can ignore tombstone edits in favor of the newer one
    if (isTombstone) {
      return;
    }

    var editParentId = getParentId(editAct);
    var existingEdit = getValue(editActivityHash, editParentId);

    // edited activity must be newer than what we already have
    if (!existingEdit || isNewer(editAct, existingEdit)) {
      setValue(editActivityHash, editParentId, editAct);
    }
  };

  // logic is identical between reactions and reaction selfs, so handler simply passes the activity and the correct hash
  var reactionHelper = function reactionHelper(reactionAct, hash) {
    var reactionParentId = getParentId(reactionAct);
    var existingReaction = getValue(hash, reactionParentId);

    // reaction activity must be newer than what we already have
    if (!existingReaction || isNewer(reactionAct, existingReaction)) {
      setValue(hash, reactionParentId, reactionAct);
    }
  };

  var handleNewReaction = function handleNewReaction(reactionAct) {
    reactionHelper(reactionAct, reactionActivityHash);
  };

  var handleNewReactionSelf = function handleNewReactionSelf(reactionSelfAct) {
    reactionHelper(reactionSelfAct, reactionSelfActivityHash);
  };

  var getActivityHandlerByKey = function getActivityHandlerByKey(key) {
    var _ACTIVITY_TYPES$REACT;

    return (_ACTIVITY_TYPES$REACT = {}, (0, _defineProperty3.default)(_ACTIVITY_TYPES$REACT, ACTIVITY_TYPES.REACTION, handleNewReaction), (0, _defineProperty3.default)(_ACTIVITY_TYPES$REACT, ACTIVITY_TYPES.REACTION_SELF, handleNewReactionSelf), (0, _defineProperty3.default)(_ACTIVITY_TYPES$REACT, ACTIVITY_TYPES.EDIT, handleNewEdit), (0, _defineProperty3.default)(_ACTIVITY_TYPES$REACT, ACTIVITY_TYPES.REPLY, handleNewReply), _ACTIVITY_TYPES$REACT)[key];
  };

  var getActivityByTypeAndParentId = function getActivityByTypeAndParentId(type, id) {
    var _ACTIVITY_TYPES$EDIT$;

    return (_ACTIVITY_TYPES$EDIT$ = {}, (0, _defineProperty3.default)(_ACTIVITY_TYPES$EDIT$, ACTIVITY_TYPES.EDIT, getValue(editActivityHash, id)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$EDIT$, ACTIVITY_TYPES.REPLY, getValue(replyActivityHash, id)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$EDIT$, ACTIVITY_TYPES.REACTION, getValue(reactionActivityHash, id)), (0, _defineProperty3.default)(_ACTIVITY_TYPES$EDIT$, ACTIVITY_TYPES.REACTION_SELF, getValue(reactionSelfActivityHash, id)), _ACTIVITY_TYPES$EDIT$)[type];
  };

  return {
    getActivityHandlerByKey: getActivityHandlerByKey,
    getActivityByTypeAndParentId: getActivityByTypeAndParentId
  };
};

/**
 * encapsulates state and logic for managing oldest and newest activities
 * @returns {object} setters and getters for activity state management
 */
var bookendManager = exports.bookendManager = function bookendManager() {
  // keep track of generator state, like what our current oldest & newest activities are
  var oldestAct = void 0;
  var newestAct = void 0;

  var getOldestAct = function getOldestAct() {
    return oldestAct;
  };
  var getNewestAct = function getNewestAct() {
    return newestAct;
  };

  var setOldestAct = function setOldestAct(act) {
    if (!oldestAct) {
      oldestAct = act;
    } else if (isNewer(oldestAct, act)) {
      oldestAct = act;
    }
  };

  var setNewestAct = function setNewestAct(act) {
    if (!newestAct) {
      newestAct = act;
    } else if (isNewer(act, newestAct)) {
      newestAct = act;
    }
  };

  var setBookends = function setBookends(activities) {
    var oldestActsFirst = sortActivitiesByPublishedDate(activities);

    var newestInBatch = (0, _last3.default)(oldestActsFirst);
    var oldestInBatch = oldestActsFirst[0];

    setOldestAct(oldestInBatch);
    setNewestAct(newestInBatch);
  };

  return {
    setBookends: setBookends,
    getNewestAct: getNewestAct,
    getOldestAct: getOldestAct
  };
};

/**
 * encapsulates state and logic for when there are no more fetchable activities from convo
 * @returns {object} setters and getters for no more activities logic
 */
var noMoreActivitiesManager = exports.noMoreActivitiesManager = function noMoreActivitiesManager() {
  // used to determine if we should continue to fetch older activities
  // must be set per iteration, as querying newer activities is still valid when all end of convo has been reached
  var noMoreActs = false;
  var noOlderActs = false;
  var noNewerActs = false;

  var getNoMoreActs = function getNoMoreActs() {
    return noMoreActs;
  };

  var checkAndSetNoOlderActs = function checkAndSetNoOlderActs(act) {
    if (!noOlderActs && getActivityType(act) === ACTIVITY_TYPES.CREATE) {
      noOlderActs = true;
    }
  };

  var checkAndSetNoNewerActs = function checkAndSetNoNewerActs(activities) {
    if (!activities || !activities.length) {
      noNewerActs = true;
    }
  };

  var checkAndSetNoMoreActs = function checkAndSetNoMoreActs(queryType) {
    if (queryType === NEWER && noNewerActs || (queryType === OLDER || queryType === INITIAL) && noOlderActs) {
      noMoreActs = true;
    }
  };

  return {
    getNoMoreActs: getNoMoreActs,
    checkAndSetNoMoreActs: checkAndSetNoMoreActs,
    checkAndSetNoNewerActs: checkAndSetNoNewerActs,
    checkAndSetNoOlderActs: checkAndSetNoOlderActs
  };
};

/**
 * encapsulates state and logic for managing root activities
 * @returns {object} setters and getters for activity state management
 */
var rootActivityManager = exports.rootActivityManager = function rootActivityManager() {
  var rootActivityHash = new _map2.default();

  var addNewRoot = function addNewRoot(rootAct) {
    setValue(rootActivityHash, rootAct.id, rootAct);
  };

  var getRootActivityHash = function getRootActivityHash() {
    return rootActivityHash;
  };

  return {
    addNewRoot: addNewRoot,
    getRootActivityHash: getRootActivityHash
  };
};

var getLoopCounterFailsafe = exports.getLoopCounterFailsafe = function getLoopCounterFailsafe() {
  var fetchLoopCount = 0;

  return function () {
    fetchLoopCount += 1;
    if (fetchLoopCount > fetchLoopCountMax) {
      throw new Error('max fetches reached');
    }
  };
};

/**
 * creates activity query object
 * @param {string} type type of query to create
 * @param {object} queryOptions options to define query
 * @param {string} [queryOptions.newestPublishedDate] the date of the newest fetched activity
 * @param {string} [queryOptions.oldestPublishedDate] the date of the oldest fetched activity
 * @param {number} [queryOptions.batchSize] the number of activities to query
 * @param {object} [queryOptions.activityToSearch] a server activity to use to build middate query
 * @returns {object}
 */
var getQuery = exports.getQuery = function getQuery(type, queryOptions) {
  var newestPublishedDate = queryOptions.newestPublishedDate,
      oldestPublishedDate = queryOptions.oldestPublishedDate,
      batchSize = queryOptions.batchSize,
      _queryOptions$activit = queryOptions.activityToSearch,
      activityToSearch = _queryOptions$activit === undefined ? {} : _queryOptions$activit;


  switch (type) {
    case NEWER:
      {
        var sinceDate = newestPublishedDate + 1;
        var lastActivityFirst = false;

        return { sinceDate: sinceDate, lastActivityFirst: lastActivityFirst };
      }
    case MID:
      {
        var searchType = getActivityType(activityToSearch);
        var midDate = void 0;

        if (searchType === ACTIVITY_TYPES.REPLY || searchType === ACTIVITY_TYPES.EDIT) {
          midDate = activityToSearch.parent.published;
        } else {
          midDate = activityToSearch.published;
        }

        return { midDate: midDate, limit: batchSize };
      }
    case OLDER:
      {
        var maxDate = oldestPublishedDate - 1;

        return { maxDate: maxDate };
      }
    case INITIAL:
    default:
      {
        return {};
      }
  }
};
//# sourceMappingURL=activity-thread-ordering.js.map
